{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar jsxRuntime = require('react/jsx-runtime');\nvar React = require('react');\nvar ConsoleLogger = require('./ConsoleLogger.js');\nvar Controller = require('./Controller.js');\nvar IntersectionObserver = require('./IntersectionObserver.js');\nvar IntervalTimer = require('./IntervalTimer.js');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nconst logger = ConsoleLogger[\"default\"].new();\nconst defaultProps = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\nconst AutoplayStateContext = React__default[\"default\"].createContext(undefined);\nfunction autoplayReducer(state, action) {\n  switch (action.type) {\n    case 'pause':\n      {\n        return Object.assign(Object.assign({}, state), {\n          isPausedByUser: true\n        });\n      }\n    case 'resume':\n      {\n        return Object.assign(Object.assign({}, state), {\n          isPausedByUser: false\n        });\n      }\n    case 'set-debounce-timeout':\n      {\n        return Object.assign(Object.assign({}, state), {\n          debounceTimeout: action.payload\n        });\n      }\n    default:\n      {\n        throw new Error(\"Unhandled action: [\".concat(JSON.stringify(action, null, 2), \"]\"));\n      }\n  }\n}\nfunction AutoplayProvider(_ref) {\n  let {\n    children,\n    autoplay\n  } = _ref;\n  var _a, _b;\n  const params = {\n    autoplayDuration: (_a = typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDuration : undefined) !== null && _a !== void 0 ? _a : defaultProps.autoplayDuration,\n    autoplayDebounce: (_b = typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDebounce : undefined) !== null && _b !== void 0 ? _b : defaultProps.autoplayDebounce\n  };\n  const [state, dispatch] = React__default[\"default\"].useReducer(autoplayReducer, {\n    isPausedByUser: false,\n    debounceTimeout: undefined\n  });\n  const {\n    state: controller,\n    changeSlide,\n    getNextSlide,\n    getSlidingCycleDuration\n  } = Controller.useController();\n  const slidingCycleDuration = getSlidingCycleDuration();\n  const autoplayCycleDuration = Math.max(slidingCycleDuration, params.autoplayDuration);\n  if (params.autoplayDuration < getSlidingCycleDuration()) logger.warn('[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).', 'The sliding cycle duration will be used instead for the autoplay intervals.');\n  const autoplayInstance = IntervalTimer[\"default\"].new(() => {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n  const {\n    isInView\n  } = IntersectionObserver.useIntersectionObserver();\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  const debounce = () => {\n    const isPausedOrIdle = autoplayInstance.state === IntervalTimer.IntervalState.IDLE || state.isPausedByUser;\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n    autoplayInstance.pause();\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n  /**\n   * Pauses the autoplay.\n   */\n  const pause = () => {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({\n      type: 'pause'\n    });\n  };\n  /**\n   * Resumes the autoplay.\n   */\n  const resume = () => {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({\n      type: 'resume'\n    });\n  };\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React__default[\"default\"].useEffect(() => {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [state.isPausedByUser]);\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React__default[\"default\"].useEffect(() => {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalTimer.IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalTimer.IntervalState.IDLE:\n          {\n            autoplayInstance.start();\n            logger.debug('[Autoplay] Started.');\n            break;\n          }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalTimer.IntervalState.PAUSED:\n          {\n            autoplayInstance.resume();\n            logger.debug('[Autoplay] Resumed.');\n            break;\n          }\n      }\n    } else if (autoplayInstance.state !== IntervalTimer.IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React__default[\"default\"].useEffect(() => {\n    return () => {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React__default[\"default\"].useEffect(() => {\n    clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [controller.activeSlide]);\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  const value = {\n    state,\n    autoplayState: autoplayInstance.state,\n    debounce,\n    pause,\n    resume\n  };\n  return jsxRuntime.jsx(AutoplayStateContext.Provider, Object.assign({\n    value: value\n  }, {\n    children: children\n  }));\n}\nfunction useAutoplay() {\n  const context = React__default[\"default\"].useContext(AutoplayStateContext);\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n  return context;\n}\nexports.AutoplayProvider = AutoplayProvider;\nexports.useAutoplay = useAutoplay;","map":{"version":3,"names":["logger","ConsoleLogger","new","defaultProps","autoplayDuration","autoplayDebounce","AutoplayStateContext","React__default","createContext","undefined","autoplayReducer","state","action","type","Object","assign","isPausedByUser","debounceTimeout","payload","Error","concat","JSON","stringify","AutoplayProvider","_ref","children","autoplay","params","_a","_b","dispatch","useReducer","controller","changeSlide","getNextSlide","getSlidingCycleDuration","Controller","useController","slidingCycleDuration","autoplayCycleDuration","Math","max","warn","autoplayInstance","IntervalTimer","activeSlide","isInView","IntersectionObserver","useIntersectionObserver","debounce","isPausedOrIdle","IntervalState","IDLE","pause","clearTimeout","setTimeout","resume","debug","useEffect","stop","start","PAUSED","info","value","autoplayState","jsxRuntime","jsx","Provider","useAutoplay","context","useContext"],"sources":["D:\\cv\\Website-Porto\\99co-frontend-test\\node_modules\\hero-slider\\src\\modules\\Autoplay.tsx"],"sourcesContent":["import React from 'react';\n\nimport ConsoleLogger from './ConsoleLogger';\nimport { useController } from './Controller';\nimport { useIntersectionObserver } from './IntersectionObserver';\nimport IntervalTimer, { IntervalState } from './IntervalTimer';\n\nconst logger = ConsoleLogger.new();\n\ninterface Props {\n  /**\n   * Autoplay duration, interval or duration betweens slide transitions, in milliseconds.\n   * If it's lower than the sliding cycle duration (sliding duration + sliding delay), then the sliding cycle duration will be used instead.\n   * @default 8000\n   */\n  autoplayDuration?: number;\n  /**\n   * Time (in milliseconds) in which the autoplay will be debounced if the user interacts with the slider.\n   * The autoplay resumes if the user stops interacting after this duration.\n   * Set as 0 to disable this feature.\n   * @default 4000\n   */\n  autoplayDebounce?: number;\n}\n\nexport type AutoplayProps = Props | boolean;\n\ntype Action =\n  | { type: 'pause' }\n  | { type: 'resume' }\n  | { type: 'set-debounce-timeout'; payload: NodeJS.Timeout };\ninterface State {\n  isPausedByUser: boolean;\n  debounceTimeout?: NodeJS.Timeout;\n}\ntype ProviderProps = React.PropsWithChildren<{\n  autoplay?: AutoplayProps;\n}>;\n\nconst defaultProps: Required<Props> = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\n\nconst AutoplayStateContext = React.createContext<\n  | {\n      state: State;\n      autoplayState: IntervalState;\n      debounce: () => void;\n      pause: () => void;\n      resume: () => void;\n    }\n  | undefined\n>(undefined);\n\nfunction autoplayReducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'pause': {\n      return { ...state, isPausedByUser: true };\n    }\n    case 'resume': {\n      return { ...state, isPausedByUser: false };\n    }\n    case 'set-debounce-timeout': {\n      return { ...state, debounceTimeout: action.payload };\n    }\n    default: {\n      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);\n    }\n  }\n}\n\nfunction AutoplayProvider({ children, autoplay }: ProviderProps) {\n  const params: Required<Props> = {\n    autoplayDuration:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDuration : undefined) ??\n      defaultProps.autoplayDuration,\n    autoplayDebounce:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDebounce : undefined) ??\n      defaultProps.autoplayDebounce\n  };\n\n  const [state, dispatch] = React.useReducer(autoplayReducer, {\n    isPausedByUser: false,\n    debounceTimeout: undefined\n  } as State);\n\n  const {\n    state: controller,\n    changeSlide,\n    getNextSlide,\n    getSlidingCycleDuration\n  } = useController();\n\n  const slidingCycleDuration = getSlidingCycleDuration();\n\n  const autoplayCycleDuration = Math.max(\n    slidingCycleDuration,\n    params.autoplayDuration\n  );\n\n  if (params.autoplayDuration < getSlidingCycleDuration())\n    logger.warn(\n      '[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).',\n      'The sliding cycle duration will be used instead for the autoplay intervals.'\n    );\n\n  const autoplayInstance = IntervalTimer.new((): void => {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n\n  const { isInView } = useIntersectionObserver();\n\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  const debounce = (): void => {\n    const isPausedOrIdle =\n      autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;\n\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n\n    autoplayInstance.pause();\n\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n\n  /**\n   * Pauses the autoplay.\n   */\n  const pause = (): void => {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({ type: 'pause' });\n  };\n\n  /**\n   * Resumes the autoplay.\n   */\n  const resume = (): void => {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({ type: 'resume' });\n  };\n\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React.useEffect(() => {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [state.isPausedByUser]);\n\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React.useEffect(() => {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalState.IDLE: {\n          autoplayInstance.start();\n          logger.debug('[Autoplay] Started.');\n          break;\n        }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalState.PAUSED: {\n          autoplayInstance.resume();\n          logger.debug('[Autoplay] Resumed.');\n          break;\n        }\n      }\n    } else if (autoplayInstance.state !== IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React.useEffect(() => {\n    clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [controller.activeSlide]);\n\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  const value = {\n    state,\n    autoplayState: autoplayInstance.state,\n    debounce,\n    pause,\n    resume\n  };\n\n  return (\n    <AutoplayStateContext.Provider value={value}>\n      {children}\n    </AutoplayStateContext.Provider>\n  );\n}\n\nfunction useAutoplay() {\n  const context = React.useContext(AutoplayStateContext);\n\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n\n  return context;\n}\n\nexport { AutoplayProvider, useAutoplay };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}